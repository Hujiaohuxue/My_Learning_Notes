---
title: 汇编语言学习笔记
grammar_cjkRuby: true
---<a class="xsj_anchor xsj_anchor_range xsj_anchor_range_start" name="xsj_1717753540635"></a>
文章链接：https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html

# 一、什么是汇<a class="xsj_anchor xsj_anchor_range xsj_anchor_range_end" name="xsj_1717753540635"></a>编语言?
我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。

这些指令都是二进制的，称为操作码（opcode），比如加法指令就是```00000011```。[编译器](https://www.ruanyifeng.com/blog/2014/11/compiler.html)的作用，就是将高级语言写好的程序，翻译成一条条操作码。

对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。

# 二、汇编语言的来历
最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。

为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成``` ADD```。内存地址也不再直接引用，而是用标签表示。

这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。

>每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。


学习汇编语言，首先需要了解两个知识点：***寄存器***与**内存模型**
# 三、寄存器
## 什么是寄存器？
**定义**：寄存器（Register）是一种小型的高速存储器件，位于中央处理器（CPU）内部，用于暂存指令、数据和地址等信息。它是计算机系统中最重要的组件之一，负责存储和提供CPU在执行指令时所需的数据和信息。

~~看不懂是吧~~，让我来给你解释一下：
>想象你是一个超快的厨师，在一家忙碌的餐厅中工作。你需要快速地完成各种菜肴，否则客人就会等待太久。
在你的厨房中，有很多不同的工具和材料，你需要快速地访问和使用它们。现在，想象你的大脑是一个超级计算机，需要快速地处理各种信息和指令。
寄存器就像你的厨房中的一个小柜台，距离你的大脑非常近。这个柜台上摆放着一些最常用的工具和材料，例如厨刀、砧板、盐、糖等等。
当你需要使用这些工具和材料时，你不需要跑到远处的仓库中去拿，因为它们已经摆放在你的柜台上了。这使得你的工作变得非常快捷和高效。

从上面的例子可以看出：```在计算机中，寄存器就是一个小型的高速存储器件，位于中央处理器（CPU）内部。它存储着当前正在执行的指令、数据和地址等信息，使得 CPU 能够快速地访问和执行指令。
寄存器的好处就在于，它可以快速地提供 CPU 需要的信息和数据，使得计算机系统的性能和效率大大提高。就像你的厨房柜台一样，寄存器让 CPU 能够快速地“拿到”所需的信息，从而提高工作效率。```<a class="xsj_anchor xsj_anchor_range xsj_anchor_range_end" name="xsj_1717752832005"></a>

**寄存器不同于内存，他并不像内存一样靠地址区分数据，每一个寄存器都有自个儿的名儿。** 总之，寄存器是 CPU 的一个重要组件，负责==存储和提供 CPU 执行指令所需的数据和信息，以提高计算机系统的性能和效率 #B78D12==。

![寄存器与其他存储器的关系](./images/无标题.png)
## 寄存器的种类
早期 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在已经有很多，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。
他们分别是
```
	·EAX
	·EBX
	·ECX
	·EDX
	·EDI
	·ESI
	·EBP
	·ESP（有特定用途）
```

# 内存模型
## 堆(Heap)
程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从```0x1000```到```0x8000```，起始地址是较小的那个地址，结束地址是较大的那个地址。
![enter description here](./images/1717985356819.png)
程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用```malloc```命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址```0x1000```开始给他分配，一直分配到地址```0x100A```，如果再要求得到22个字节，那么就分配到```0x1020```。
这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，**从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。**

## 栈（stack）
跟oi的栈差不多都是先进后出
栈是由于**函数运行而临时占用的内存区域。**![Screenshot 2024-06-10 101418入栈与出栈的过程](./images/Screenshot_2024-06-10_101418.png)
Stack 是由内存区域的结束地址开始，**从高位（地址）向低位（地址）分配**。比如，内存区域的结束地址是```0x8000```，第一帧假定是16字节，那么下一次分配的地址就会从```0x7FF0```开始；第二帧假定需要64字节，那么地址就会移动到```0x7FB0```

学完了寄存器还有内存模型的概念以后，我们就一开始正式进行汇编语言的学习了

# CPU指令
## 开胃小菜
先来一段C语言代码
``` c
//homo.c
#include <stdio.h>
int ab(int a,b){
	return a + b;
}
int main(){
	return ab(1,114514);  //怎么到哪儿都有homo啊（悲
}
```
C语言转汇编指令：```gcc -S homo.c```